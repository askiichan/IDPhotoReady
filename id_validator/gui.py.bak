"""
GUI for the ID Photo Validator application.
"""

import os
import tkinter as tk
import cv2
from tkinter import filedialog, ttk
import threading
import time
from PIL import Image, ImageTk

from .config import (
    FACE_PROTO, FACE_MODEL, LANDMARK_MODEL,
    FACE_PROTO_URL, FACE_MODEL_URL, LANDMARK_MODEL_URL
)
from .utils import download_file
from .validator import validate_id_photo
from .validation_config import ValidationConfig, STRICT_CONFIG, BASIC_CONFIG, LENIENT_CONFIG

class IDPhotoValidatorGUI:
    """
    The main GUI class for the ID Photo Validator application.
    """
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title("ID Photo Validator")
        self.root.geometry("1400x900")
        self.root.minsize(1200, 700)
        self.root.configure(bg="#f8f9fa")

        self.current_image_path = None
        self.models_downloading = False
        self.validation_config = ValidationConfig()  # Default config
        
        # Validation configuration variables
        self.face_sizing_var = tk.BooleanVar(value=True)
        self.landmark_analysis_var = tk.BooleanVar(value=True)
        self.eye_validation_var = tk.BooleanVar(value=True)
        self.obstruction_detection_var = tk.BooleanVar(value=True)
        self.mouth_validation_var = tk.BooleanVar(value=True)
        self.quality_assessment_var = tk.BooleanVar(value=True)
        self.background_validation_var = tk.BooleanVar(value=True)

        # Batch processing variables
        self.batch_results = []
        self.current_batch_index = 0

        self._setup_styles()
        self._create_widgets()
        self._check_and_download_models()

    def _setup_styles(self):
        style = ttk.Style()
        style.configure("TFrame", background="#f8f9fa")
        style.configure("TLabel", background="#f8f9fa", font=("Segoe UI", 11))
        style.configure("TButton", font=("Segoe UI", 11, "bold"), padding=8)
        style.configure("Header.TLabel", font=("Segoe UI", 16, "bold"), foreground="#2c3e50", background="#f8f9fa")
        style.configure("SubHeader.TLabel", font=("Segoe UI", 13, "bold"), foreground="#34495e", background="#f8f9fa")
        style.configure("Success.TLabel", font=("Segoe UI", 11, "bold"), foreground="#27ae60", background="#f8f9fa")
        style.configure("Failure.TLabel", font=("Segoe UI", 11, "bold"), foreground="#e74c3c", background="#f8f9fa")
        style.configure("Info.TLabel", font=("Segoe UI", 10), foreground="#7f8c8d", background="#f8f9fa")

    def _create_widgets(self):
        # Create main paned window for adjustable panels
        main_paned = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_paned.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Left panel for input image
        left_panel = ttk.Frame(main_paned, relief=tk.RAISED, borderwidth=2)
        main_paned.add(left_panel, weight=1)
        
        # Middle panel for configuration
        config_panel = ttk.Frame(main_paned, relief=tk.RAISED, borderwidth=2)
        main_paned.add(config_panel, weight=0)
        
        # Right panel for results
        right_panel = ttk.Frame(main_paned, relief=tk.RAISED, borderwidth=2)
        main_paned.add(right_panel, weight=1)
        
        # --- Left Panel: Image Upload and Display ---
        ttk.Label(left_panel, text="Input Image", style="Header.TLabel").pack(pady=(10, 5))
        self.image_label = ttk.Label(left_panel, text="Upload an image to begin", 
                                    relief="solid", borderwidth=1, 
                                    background="white", anchor="center")
        self.image_label.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        # Button frame for input actions
        input_btn_frame = ttk.Frame(left_panel)
        input_btn_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        self.upload_btn = ttk.Button(input_btn_frame, text="Upload Image", command=self.upload_image)
        self.upload_btn.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(0, 5))
        
        self.validate_btn = ttk.Button(input_btn_frame, text="Validate Photo", 
                                      command=self.validate_image, state=tk.DISABLED)
        self.validate_btn.pack(side=tk.RIGHT, expand=True, fill=tk.X, padx=(5, 0))
        
        # Batch processing button
        self.batch_btn = ttk.Button(left_panel, text="Batch Process Folder", command=self.process_folder)
        self.batch_btn.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # Progress frame for batch processing
        self.progress_frame = ttk.Frame(left_panel)
        self.progress_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        self.progress_label = ttk.Label(self.progress_frame, text="", style="Info.TLabel")
        self.progress_label.pack()
        
        self.progress_bar = ttk.Progressbar(self.progress_frame, mode='determinate')
        self.progress_bar.pack(fill=tk.X, pady=(5, 0))
        
        # --- Configuration Panel ---
        self.setup_config_panel(config_panel)
        
        # --- Right Panel: Validation Results ---
        # Create notebook for tabbed results interface
        self.results_notebook = ttk.Notebook(right_panel)
        self.results_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Single validation tab
        self.single_result_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(self.single_result_frame, text="Single Result")
        
        # Batch validation tab
        self.batch_result_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(self.batch_result_frame, text="Batch Results")
        
        # --- Single Result Tab ---
        ttk.Label(self.single_result_frame, text="Validation Result", style="Header.TLabel").pack(pady=(10, 5))
        self.result_image_label = ttk.Label(self.single_result_frame, text="Validation pending...", 
                                          relief="solid", borderwidth=1, 
                                          background="white", anchor="center")
        self.result_image_label.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        self.result_text = tk.Text(self.single_result_frame, height=10, wrap=tk.WORD, 
                                  font=("Segoe UI", 10), relief="flat", bg="#ffffff")
        self.result_text.pack(pady=(0, 10), padx=10, fill=tk.BOTH, expand=True)
        self.result_text.tag_configure("success", foreground="#27ae60", font=("Segoe UI", 11, "bold"))
        self.result_text.tag_configure("failure", foreground="#e74c3c", font=("Segoe UI", 11, "bold"))
        self.result_text.tag_configure("reason", foreground="#7f8c8d", font=("Segoe UI", 10))
        self.result_text.tag_configure("time", foreground="#3498db", font=("Segoe UI", 9, "italic"))
        self.result_text.config(state=tk.DISABLED)
        
        # Add scrollbar to results text
        single_scrollbar = ttk.Scrollbar(self.single_result_frame, orient=tk.VERTICAL, command=self.result_text.yview)
        single_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.result_text.config(yscrollcommand=single_scrollbar.set)
        
        # --- Batch Result Tab ---
        # Create a canvas and scrollbar for batch results
        self.batch_canvas = tk.Canvas(self.batch_result_frame, bg="#ffffff")
        self.batch_scrollbar = ttk.Scrollbar(self.batch_result_frame, orient=tk.VERTICAL, command=self.batch_canvas.yview)
        self.batch_scrollable_frame = ttk.Frame(self.batch_canvas)
        
        self.batch_canvas.configure(yscrollcommand=self.batch_scrollbar.set)
        self.batch_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        self.batch_scrollbar.pack(side=tk.RIGHT, fill=tk.Y, padx=(0, 10), pady=10)
        
        # Create window in canvas for scrollable frame
        self.batch_canvas_window = self.batch_canvas.create_window((0, 0), window=self.batch_scrollable_frame, anchor="nw")
        self.batch_scrollable_frame.bind("<Configure>", self._on_batch_frame_configure)
        self.batch_canvas.bind("<Configure>", self._on_batch_canvas_configure)
        self.batch_canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # Navigation frame removed

    def _check_and_download_models(self):
        models_to_check = {
            "Face Protoxt": (FACE_PROTO_URL, FACE_PROTO),
            "Face Model": (FACE_MODEL_URL, FACE_MODEL),
            "Landmark Model": (LANDMARK_MODEL_URL, LANDMARK_MODEL)
        }

        missing_models = {name: (url, path) for name, (url, path) in models_to_check.items() if not os.path.exists(path)}

        if missing_models:
            self.models_downloading = True
            self.show_result_message("Downloading required models... Please wait.", "failure")
            self.upload_btn.config(state=tk.DISABLED)
            self.validate_btn.config(state=tk.DISABLED)

            download_thread = threading.Thread(target=self._download_worker, args=(missing_models,), daemon=True)
            download_thread.start()

    def _download_worker(self, models_to_download):
        try:
            for name, (url, path) in models_to_download.items():
                download_file(url, path, desc=name)
            self.show_result_message("Models downloaded successfully. You can now upload an image.", "success")
        except Exception as e:
            self.show_result_message(f"Failed to download models: {e}. Please check your connection and restart.", "failure")
        finally:
            self.models_downloading = False
            self.upload_btn.config(state=tk.NORMAL)

    def upload_image(self):
        if self.models_downloading:
            self.show_result_message("Please wait for models to finish downloading.", "failure")
            return

        path = filedialog.askopenfilename(filetypes=[
            ("Image Files", "*.jpg *.jpeg *.png *.bmp"),
            ("All files", "*.*")
        ])
        if not path:
            return

        self.current_image_path = path
        self.display_image(self.image_label, path)
        self.validate_btn.config(state=tk.NORMAL)
        self.show_result_message("Image loaded. Click 'Validate Photo' to proceed.", "reason")
        self.result_image_label.configure(image='')
        self.result_image_label.image = None

    def validate_image(self):
        if not self.current_image_path:
            return

        start_time = time.time()
        try:
            is_valid, reasons, annotated_img = validate_id_photo(self.current_image_path, return_annotated=True, config=self.validation_config)
            end_time = time.time()
            processing_time = end_time - start_time

            self.display_results(is_valid, reasons, processing_time)
            if annotated_img is not None:
                self.display_image(self.result_image_label, annotated_img, is_cv2_img=True)
            else:
                self.result_image_label.configure(image='')
                self.result_image_label.image = None

        except Exception as e:
            end_time = time.time()
            self.display_results(False, [f"An unexpected error occurred: {e}"], end_time - start_time)

    def process_folder(self):
        """Process all images in a selected folder."""
        if self.models_downloading:
            self.show_result_message("Please wait for models to finish downloading.", "failure")
            return

        folder_path = filedialog.askdirectory()
        if not folder_path:
            return

        # Get all image files in the folder
        image_extensions = ('.jpg', '.jpeg', '.png', '.bmp')
        image_files = [f for f in os.listdir(folder_path) 
                      if f.lower().endswith(image_extensions) and 
                      os.path.isfile(os.path.join(folder_path, f))]

        if not image_files:
            self.show_result_message("No image files found in the selected folder.", "failure")
            return

        # Disable buttons during processing
        self.upload_btn.config(state=tk.DISABLED)
        self.validate_btn.config(state=tk.DISABLED)
        self.batch_btn.config(state=tk.DISABLED)

        # Start batch processing in a separate thread
        batch_thread = threading.Thread(target=self._batch_process_worker, 
                                       args=(folder_path, image_files), daemon=True)
        batch_thread.start()

    def _batch_process_worker(self, folder_path, image_files):
        """Worker function for batch processing."""
        try:
            # Initialize results tracking
            total_files = len(image_files)
            passed_count = 0
            failed_count = 0
            results = []
            
            # Process each image
            for i, filename in enumerate(image_files):
                file_path = os.path.join(folder_path, filename)
                
                # Update progress
                self.progress_label.config(text=f"Processing: {filename}")
                self.progress_bar['value'] = (i / total_files) * 100
                self.root.update_idletasks()
                
                # Validate image
                try:
                    start_time = time.time()
                    is_valid, reasons, annotated_img = validate_id_photo(file_path, return_annotated=True, config=self.validation_config)
                    end_time = time.time()
                    processing_time = end_time - start_time
                    
                    results.append({
                        'filename': filename,
                        'file_path': file_path,
                        'passed': is_valid,
                        'reasons': reasons,
                        'time': processing_time,
                        'annotated_img': annotated_img
                    })
                    
                    if is_valid:
                        passed_count += 1
                    else:
                        failed_count += 1
                        
                except Exception as e:
                    results.append({
                        'filename': filename,
                        'file_path': file_path,
                        'passed': False,
                        'reasons': [f"Error: {str(e)}"],
                        'time': 0,
                        'annotated_img': None
                    })
                    failed_count += 1
            
            # Complete progress bar
            self.progress_bar['value'] = 100
            self.progress_label.config(text="Processing complete!")
            
            # Display batch results
            self.display_batch_results(results, total_files, passed_count, failed_count)
            
        except Exception as e:
            self.show_result_message(f"Batch processing failed: {str(e)}", "failure")
        finally:
            # Re-enable buttons
            self.upload_btn.config(state=tk.NORMAL)
            self.validate_btn.config(state=tk.NORMAL)
            self.batch_btn.config(state=tk.NORMAL)
            
            # Reset progress after a delay
            self.root.after(3000, self._reset_progress)

    def _reset_progress(self):
        """Reset progress bar and label after processing."""
        self.progress_bar['value'] = 0
        self.progress_label.config(text="")

    def display_batch_results(self, results, total_files, passed_count, failed_count):
        """Display results for batch processing."""
        # Store results for navigation
        self.batch_results = results
        self.current_batch_index = 0
        
        # Update text results
        self.result_text.config(state=tk.NORMAL)
        self.result_text.delete(1.0, tk.END)
        
        # Summary
        self.result_text.insert(tk.END, f"Batch Processing Complete\n", "success")
        self.result_text.insert(tk.END, f"Total files processed: {total_files}\n", "reason")
        self.result_text.insert(tk.END, f"Passed: {passed_count}\n", "success")
        self.result_text.insert(tk.END, f"Failed: {failed_count}\n\n", "failure")
        
        # Detailed results
        self.result_text.insert(tk.END, "Detailed Results:\n", "reason")
        self.result_text.insert(tk.END, "-" * 40 + "\n")
        
        for result in results:
            status = "PASSED" if result['passed'] else "FAILED"
            tag = "success" if result['passed'] else "failure"
            self.result_text.insert(tk.END, f"{result['filename']}: {status}\n", tag)
            
            if not result['passed']:
                for reason in result['reasons']:
                    self.result_text.insert(tk.END, f"  - {reason}\n", "reason")
            
            self.result_text.insert(tk.END, f"  Processing time: {result['time']:.2f} seconds\n\n", "time")
        
        self.result_text.config(state=tk.DISABLED)

def _reset_progress(self):
    """Reset progress bar and label after processing."""
    self.progress_bar['value'] = 0
    self.progress_label.config(text="")

def display_batch_results(self, results, total_files, passed_count, failed_count):
    """Display results for batch processing."""
    # Store results for navigation
    self.batch_results = results
    self.current_batch_index = 0
        if is_valid:
            self.result_text.insert(tk.END, "Validation Passed!\n", "success")
            self.result_text.insert(tk.END, "The photo meets all requirements.", "reason")
        else:
            self.result_text.insert(tk.END, "Validation Failed\n", "failure")
            for reason in reasons:
                self.result_text.insert(tk.END, f"- {reason}\n", "reason")
        
        self.result_text.insert(tk.END, f"\n\nProcessing time: {duration:.2f} seconds", "time")
        self.result_text.config(state=tk.DISABLED)

    def show_result_message(self, message, tag):
        self.result_text.config(state=tk.NORMAL)
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(tk.END, message, tag)
        self.result_text.config(state=tk.DISABLED)
    
    def _on_batch_frame_configure(self, event):
        """Update scroll region when batch frame is resized."""
        self.batch_canvas.configure(scrollregion=self.batch_canvas.bbox("all"))
    
    def _on_batch_canvas_configure(self, event):
        """Update frame width when canvas is resized."""
        canvas_width = event.width
        self.batch_canvas.itemconfig(self.batch_canvas_window, width=canvas_width)
    def _on_mousewheel(self, event):
        """Handle mousewheel scrolling for batch results."""
        self.batch_canvas.yview_scroll(int(-1*(event.delta/120)), "units")

    def _display_batch_item(self, index):
        """Display a specific batch item (navigation removed)."""
        # This method is kept as a stub for compatibility
        pass

    def setup_config_panel(self, parent):
        """Setup the validation configuration panel."""
        # Configuration panel header
        config_label = ttk.Label(parent, text="Validation Settings", font=("Arial", 12, "bold"))
        config_label.pack(pady=(0, 10))
        
        # Preset configurations frame
        preset_frame = ttk.LabelFrame(parent, text="Presets", padding=10)
        preset_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(preset_frame, text="Strict (All)", command=self.apply_strict_config).pack(fill=tk.X, pady=2)
        ttk.Button(preset_frame, text="Basic", command=self.apply_basic_config).pack(fill=tk.X, pady=2)
        ttk.Button(preset_frame, text="Lenient", command=self.apply_lenient_config).pack(fill=tk.X, pady=2)
        
        # Individual validation categories
        categories_frame = ttk.LabelFrame(parent, text="Validation Categories", padding=10)
        categories_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Core validations (always enabled)
        ttk.Label(categories_frame, text="Core (Always On):", font=("Arial", 9, "bold")).pack(anchor=tk.W)
        ttk.Label(categories_frame, text="• File Handling", foreground="gray").pack(anchor=tk.W, padx=10)
        ttk.Label(categories_frame, text="• Face Detection", foreground="gray").pack(anchor=tk.W, padx=10)
        
        ttk.Separator(categories_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=5)
        
        # Configurable validations
        ttk.Label(categories_frame, text="Configurable:", font=("Arial", 9, "bold")).pack(anchor=tk.W)
        
        ttk.Checkbutton(categories_frame, text="Face Sizing", variable=self.face_sizing_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        ttk.Checkbutton(categories_frame, text="Landmark Analysis", variable=self.landmark_analysis_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        ttk.Checkbutton(categories_frame, text="Eye Validation", variable=self.eye_validation_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        ttk.Checkbutton(categories_frame, text="Obstruction Detection", variable=self.obstruction_detection_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        ttk.Checkbutton(categories_frame, text="Mouth Validation", variable=self.mouth_validation_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        ttk.Checkbutton(categories_frame, text="Quality Assessment", variable=self.quality_assessment_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        ttk.Checkbutton(categories_frame, text="Background Validation", variable=self.background_validation_var, 
                       command=self.update_config).pack(anchor=tk.W, padx=10)
        
        # Current config display
        self.config_status_label = ttk.Label(parent, text="", font=("Arial", 8), foreground="blue")
        self.config_status_label.pack(pady=(10, 0))
        
        # Update initial status
        self.update_config_status()
    
    def apply_strict_config(self):
        """Apply strict validation configuration."""
        self.face_sizing_var.set(True)
        self.landmark_analysis_var.set(True)
        self.eye_validation_var.set(True)
        self.obstruction_detection_var.set(True)
        self.mouth_validation_var.set(True)
        self.quality_assessment_var.set(True)
        self.background_validation_var.set(True)
        self.update_config()
    
    def apply_basic_config(self):
        """Apply basic validation configuration."""
        self.face_sizing_var.set(True)
        self.landmark_analysis_var.set(False)
        self.eye_validation_var.set(True)
        self.obstruction_detection_var.set(False)
        self.mouth_validation_var.set(False)
        self.quality_assessment_var.set(False)
        self.background_validation_var.set(True)
        self.update_config()
    
    def apply_lenient_config(self):
        """Apply lenient validation configuration."""
        self.face_sizing_var.set(False)
        self.landmark_analysis_var.set(False)
        self.eye_validation_var.set(False)
        self.obstruction_detection_var.set(False)
        self.mouth_validation_var.set(False)
        self.quality_assessment_var.set(False)
        self.background_validation_var.set(False)
        self.update_config()
    
    def update_config(self):
        """Update the validation configuration based on checkbox states."""
        self.validation_config = ValidationConfig(
            face_sizing=self.face_sizing_var.get(),
            landmark_analysis=self.landmark_analysis_var.get(),
            eye_validation=self.eye_validation_var.get(),
            obstruction_detection=self.obstruction_detection_var.get(),
            mouth_validation=self.mouth_validation_var.get(),
            quality_assessment=self.quality_assessment_var.get(),
            background_validation=self.background_validation_var.get()
        )
        self.update_config_status()
    
    def update_config_status(self):
        """Update the configuration status display."""
        enabled = self.validation_config.get_enabled_categories()
        if len(enabled) == 7:
            status = "Strict Mode (All)"
        elif len(enabled) == 0:
            status = "Lenient Mode (Core Only)"
        else:
            status = f"Custom ({len(enabled)}/7 enabled)"
        
        self.config_status_label.config(text=f"Current: {status}")
    
    def _update_batch_results_images(self):
        """Update the batch results tab with images for each result."""
        # Clear previous results
        for widget in self.batch_scrollable_frame.winfo_children():
            widget.destroy()
        
        # Display each result with input and output images
        for i, result in enumerate(self.batch_results):
            # Create a frame for this result
            result_frame = ttk.Frame(self.batch_scrollable_frame, relief=tk.RAISED, borderwidth=1)
            result_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # Result header
            status_text = "PASSED" if result['passed'] else "FAILED"
            status_style = "Success.TLabel" if result['passed'] else "Failure.TLabel"
            header_frame = ttk.Frame(result_frame)
            header_frame.pack(fill=tk.X, padx=5, pady=5)
            
            ttk.Label(header_frame, text=f"{i+1}. {result['filename']}", style="SubHeader.TLabel").pack(side=tk.LEFT)
            ttk.Label(header_frame, text=status_text, style=status_style).pack(side=tk.RIGHT)
            
            # Create a frame for images
            images_frame = ttk.Frame(result_frame)
            images_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # Input image
            input_frame = ttk.Frame(images_frame)
            input_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            ttk.Label(input_frame, text="Input Image", style="Info.TLabel").pack()
            input_label = ttk.Label(input_frame, relief="solid", borderwidth=1, background="white")
            input_label.pack(fill=tk.BOTH, expand=True)
            
            # Display input image
            if 'file_path' in result and os.path.exists(result['file_path']):
                self.display_image(input_label, result['file_path'])
            else:
                input_label.configure(text="Image not available")
            
            # Output image (annotated)
            output_frame = ttk.Frame(images_frame)
            output_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5)
            ttk.Label(output_frame, text="Output Image", style="Info.TLabel").pack()
            output_label = ttk.Label(output_frame, relief="solid", borderwidth=1, background="white")
            output_label.pack(fill=tk.BOTH, expand=True)
            
            # Display output image
            if result['annotated_img'] is not None:
                self.display_image(output_label, result['annotated_img'], is_cv2_img=True)
            else:
                output_label.configure(text="No annotated image")
            
            # Reasons text
            if not result['passed'] and result['reasons']:
                reasons_frame = ttk.Frame(result_frame)
                reasons_frame.pack(fill=tk.X, padx=5, pady=5)
                ttk.Label(reasons_frame, text="Failure Reasons:", style="Info.TLabel").pack(anchor=tk.W)
                
                reasons_text = tk.Text(reasons_frame, height=3, wrap=tk.WORD, font=("Segoe UI", 9))
                reasons_text.pack(fill=tk.X, pady=(0, 5))
                for reason in result['reasons']:
                    reasons_text.insert(tk.END, f"• {reason}\n")
                reasons_text.config(state=tk.DISABLED)
            
            # Processing time
            time_frame = ttk.Frame(result_frame)
            time_frame.pack(fill=tk.X, padx=5, pady=5)
            ttk.Label(time_frame, text=f"Processing time: {result['time']:.2f} seconds", style="Info.TLabel").pack(anchor=tk.E)
        
        # Navigation removed
